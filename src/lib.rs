//! # Archibald - High-Performance Instruction Decoder Generator
//!
//! Archibald is a procedural macro that generates optimized instruction decoders with
//! compile-time branch elimination. It allows you to define instruction patterns using
//! intuitive bit patterns (like `"1011xxyy"`) and automatically generates a dispatcher
//! function that calls const-generic handlers.
//!
//! ## Features
//!
//! - **Compile-time branch elimination**: Variable bits are expanded into const generics,
//!   allowing the compiler to eliminate branches and inline specialized code paths
//! - **Declarative syntax**: Easy-to-read instruction tables that resemble hardware specs
//! - **Flexible mappings**: Support for enum mappings, const function decoders or just passing the bits through
//!
//! ## Pattern Syntax
//!
//! Patterns use the following characters:
//! - `0`, `1` - Fixed bits that must match exactly
//! - `a-z` - Variable bits (e.g., `rr`, `mm`) that are extracted and passed as const generics
//! - `_`, `.` - Wildcard bits - useful for immediate values embedded in opcodes
//! - `'` - Visual separator (ignored) - use for readability like `"1100'xxyy"`
//!
//! ## Usage
//!
//! This example demonstrates all major features:
//!
//! ```rust
//! use archibald::instruction_table;
//!
//! #[derive(Debug, PartialEq, Eq, core::marker::ConstParamTy)]
//! enum Register { R0, R1, R2, R3 }
//!
//! #[derive(Debug, PartialEq, Eq, core::marker::ConstParamTy)]
//! enum Mode { Direct, Indirect }
//!
//! // Const function for decoding mode bit
//! const fn decode_mode(bit: u8) -> Mode {
//!     match bit { 0 => Mode::Direct, 1 => Mode::Indirect, _ => unreachable!() }
//! }
//!
//! // Const function for converting bit to bool
//! const fn bit_to_bool(bit: u8) -> bool { bit != 0 }
//!
//! instruction_table! {
//!     type Opcode = u8;
//!
//!     dispatcher = dispatch;
//!     context = Cpu;
//!
//!     // Fixed pattern - no variables
//!     "0000'0000" => nop;
//!
//!     // Manual enum mapping with multiple variables
//!     "0001'ddss" => move_reg<{d}, {s}> where {
//!         d: Register = { 0b00 => R0, 0b01 => R1, 0b10 => R2, 0b11 => R3 },
//!         s: Register = { 0b00 => R0, 0b01 => R1, 0b10 => R2, 0b11 => R3 }
//!     };
//!
//!     // Const function mapping - enum
//!     "0010'mrr_" => load<{m}, {r}> where {
//!         m: Mode = decode_mode(m),
//!         r: Register = { 0b00 => R0, 0b01 => R1, 0b10 => R2, 0b11 => R3 }
//!     };
//!
//!     // Const function mapping - bool
//!     "0011'i___" => store<{i}> where {
//!         i: bool = bit_to_bool(i)
//!     };
//!
//!     // Passthrough u8 - no where clause (currently always u8 regardless of Opcode type)
//!     "0100'00oo" => alu<{o}>;
//! }
//!
//! // Handler implementations, all branches will be eliminated at compile time due to specialization
//! fn nop(_cpu: &mut Cpu, _opcode: u8) { }
//!
//! fn move_reg<const DST: Register, const SRC: Register>(cpu: &mut Cpu, _opcode: u8) {
//!     cpu.regs[DST as usize] = cpu.regs[SRC as usize];
//! }
//!
//! fn load<const MODE: Mode, const REG: Register>(cpu: &mut Cpu, opcode: u8) {
//!     let addr = match MODE {
//!         Mode::Direct => opcode & 0x1,
//!         Mode::Indirect => cpu.regs[opcode as usize & 0x1],
//!     };
//!     cpu.regs[REG as usize] = cpu.memory[addr as usize];
//! }
//!
//! fn store<const IMMEDIATE: bool>(cpu: &mut Cpu, opcode: u8) {
//!     if IMMEDIATE {
//!         cpu.memory[0] = opcode & 0x0F;
//!     } else {
//!         cpu.memory[0] = cpu.regs[0];
//!     }
//! }
//!
//! fn alu<const OP: u8>(cpu: &mut Cpu, _opcode: u8) {
//!     cpu.regs[0] = match OP {
//!         0 => cpu.regs[0] << 1,  // SHL
//!         1 => cpu.regs[0] >> 1,  // SHR
//!         2 => cpu.regs[0] + 1,   // INC
//!         3 => cpu.regs[0] - 1,   // DEC
//!         _ => unreachable!()
//!     };
//! }
//! ```
//!
//! ## Dispatcher Function
//!
//! The `dispatcher` function generated by the macro is what you want to call to decode
//! and execute instructions. It takes a mutable reference to the provided context.
//! The expanded function will look similar to this:
//!
//! ```rust
//! #[inline]
//! pub fn dispatch(ctx: &mut (), opcode: u8) {
//!     match opcode {
//!         op if op & 240u8 == 0u8 => handler::<{ decode_mode(0u8) }>(ctx, opcode),
//!         op if op & 240u8 == 16u8 => handler::<{ decode_mode(1u8) }>(ctx, opcode),
//!         op if op & 240u8 == 32u8 => handler::<{ decode_mode(2u8) }>(ctx, opcode),
//!         op if op & 240u8 == 48u8 => handler::<{ decode_mode(3u8) }>(ctx, opcode),
//!         op if op & 240u8 == 64u8 => handler::<{ Mode::A }>(ctx, opcode),
//!         op if op & 240u8 == 80u8 => handler::<{ Mode::B }>(ctx, opcode),
//!         op if op & 240u8 == 96u8 => handler::<{ Mode::C }>(ctx, opcode),
//!         op if op & 240u8 == 112u8 => handler::<{ Mode::D }>(ctx, opcode),
//!         _ => {
//!             ::core::panicking::panic_fmt(
//!                 format_args!("Unhandled opcode: 0x{0:02X}", opcode),
//!             );
//!         }
//!     }
//! }
//! ```
//!
//! ## Notes
//!
//! - Requires nightly Rust with `#![feature(adt_const_params)]` for enum const generics
//! - Enums used as const generics must implement `ConstParamTy`, `PartialEq`, and `Eq`
//! - Const functions must be marked with `const fn`
//! - Patterns must be exactly 8, 16, 32, or 64 bits (after removing `'` separators)
//! - Variables without where clauses (passthrough) always generate `u8` literals

use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use quote::{format_ident, quote};
use std::collections::HashMap;
use syn::{
    Ident, LitInt, LitStr, Path, Token, Type, braced,
    parse::{Parse, ParseStream},
    parse_macro_input,
    punctuated::Punctuated,
    token,
};

/// A single bit-to-variant mapping used in manual enum mappings.
///
/// Represents one entry in a manual mapping like `0b00 => R0`.
/// Supports both `0b` prefixed and plain binary literals.
#[derive(Clone)]
struct BitMapping {
    /// The bit pattern as a binary string (e.g., "00", "01")
    bits: String,
    /// The enum variant identifier (e.g., `R0`)
    variant: Ident,
}

impl Parse for BitMapping {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let bits_lit: LitInt = input.parse()?;
        let bits_str = bits_lit.to_string();

        // Handle both "0b00" and "00" formats, normalize to binary digits only
        let bits = if bits_str.starts_with("0b") || bits_str.starts_with("0B") {
            bits_str[2..].to_string()
        } else {
            // Assume it's already binary digits
            bits_str
        };

        input.parse::<Token![=>]>()?;
        let variant: Ident = input.parse()?;
        Ok(BitMapping { bits, variant })
    }
}

/// The value side of a variable binding.
///
/// Variables can be bound in two ways:
/// 1. Manual mapping: `{ 0b00 => R0, 0b01 => R1, ... }` - explicitly map each bit pattern
/// 2. Const function: `decode_mode(m)` - call a const fn to compute the value
#[derive(Clone)]
enum BindingValue {
    /// Manual enum mapping with explicit bit patterns
    Mappings(Vec<BitMapping>),
    /// Const function call that computes the value from bits
    ConstFn(TokenStream2),
}

/// A variable binding from a where clause.
///
/// Binds a pattern variable (like `mm` from `"00mm____"`) to either:
/// - A manual enum mapping: `mm: Mode = { 0b00 => A, 0b01 => B, ... }`
/// - A const function: `mm: Mode = decode_mode(mm)`
struct VariableBinding {
    /// Variable name (e.g., "mm", "r", "dd")
    name: String,
    /// Optional type annotation for adding enum prefixes (e.g., `Register`, `Mode`, `m68k::Direction`)
    enum_type: Option<Path>,
    /// The binding value (manual mapping or const function)
    value: BindingValue,
}

impl Parse for VariableBinding {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let name_ident: Ident = input.parse()?;
        let name = name_ident.to_string();

        // Optional type annotation
        let enum_type = if input.peek(Token![:]) {
            input.parse::<Token![:]>()?;

            // Parse path manually to avoid consuming tokens beyond the type
            let mut segments = Punctuated::new();

            // Parse first segment
            let first_ident: Ident = input.parse()?;
            segments.push(syn::PathSegment {
                ident: first_ident,
                arguments: syn::PathArguments::None,
            });

            // Parse additional segments separated by `::`
            while input.peek(Token![::]) {
                input.parse::<Token![::]>()?;
                let ident: Ident = input.parse()?;
                segments.push(syn::PathSegment {
                    ident,
                    arguments: syn::PathArguments::None,
                });
            }

            Some(Path {
                leading_colon: None,
                segments,
            })
        } else {
            None
        };

        input.parse::<Token![=]>()?;

        let value = if input.peek(token::Brace) {
            // Manual mapping: { 0b00 => R0, ... }
            let content;
            braced!(content in input);

            let mappings: Punctuated<BitMapping, Token![,]> =
                content.parse_terminated(BitMapping::parse, Token![,])?;

            BindingValue::Mappings(mappings.into_iter().collect())
        } else {
            // Const function call: translate_register(r)
            // Parse tokens until we hit a comma or end of input
            let mut tokens = TokenStream2::new();
            while !input.is_empty() && !input.peek(Token![,]) {
                let tt: proc_macro2::TokenTree = input.parse()?;
                tokens.extend(std::iter::once(tt));
            }
            BindingValue::ConstFn(tokens)
        };

        Ok(VariableBinding {
            name,
            enum_type,
            value,
        })
    }
}

/// A where clause containing variable bindings.
///
/// Syntax: `where { mm: Mode = ..., r: Register = ... }`
struct WhereClause {
    /// All variable bindings in the where clause
    bindings: Vec<VariableBinding>,
}

impl Parse for WhereClause {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        input.parse::<Token![where]>()?;
        let content;
        braced!(content in input);

        let bindings: Punctuated<VariableBinding, Token![,]> =
            content.parse_terminated(VariableBinding::parse, Token![,])?;

        Ok(WhereClause {
            bindings: bindings.into_iter().collect(),
        })
    }
}

/// A handler function call specification with optional const generic arguments.
///
/// Examples:
/// - `nop` - no generics
/// - `load<{r}>` - single variable (type from where clause)
/// - `move_reg<{d}, {s}>` - multiple variables
/// - `alu<{op}>` - variable without where clause (primitive type)
/// - `m68k::shift_left` - path to handler function
struct HandlerSpec {
    /// Handler function name (can be a path like `m68k::shift_left`)
    name: Path,
    /// Variable names from const generic arguments (e.g., ["r"], ["d", "s"])
    generics: Vec<String>,
}

impl Parse for HandlerSpec {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        // Parse path manually to avoid consuming the custom generic syntax <{var}>
        // We want to parse: `ident`, `ident::ident`, `ident::ident::ident`, etc.
        // But NOT the `<{...}>` part which comes after
        let mut segments = Punctuated::new();

        // Parse first segment
        let first_ident: Ident = input.parse()?;
        segments.push(syn::PathSegment {
            ident: first_ident,
            arguments: syn::PathArguments::None,
        });

        // Parse additional segments separated by `::`
        while input.peek(Token![::]) {
            input.parse::<Token![::]>()?;
            let ident: Ident = input.parse()?;
            segments.push(syn::PathSegment {
                ident,
                arguments: syn::PathArguments::None,
            });
        }

        let name = Path {
            leading_colon: None,
            segments,
        };

        let generics = if input.peek(Token![<]) {
            input.parse::<Token![<]>()?;
            let mut args = Vec::new();

            loop {
                if input.peek(Token![>]) {
                    break;
                }

                // Parse {var}
                let content;
                braced!(content in input);
                let var_ident: Ident = content.parse()?;
                args.push(var_ident.to_string());

                if input.peek(Token![,]) {
                    input.parse::<Token![,]>()?;
                } else {
                    break;
                }
            }

            input.parse::<Token![>]>()?;
            args
        } else {
            Vec::new()
        };

        Ok(HandlerSpec { name, generics })
    }
}

/// A single instruction pattern entry.
///
/// Syntax: `"pattern" => handler<...> where { ... };`
///
/// Example: `"0001'00rr" => load<{r}> where { r: Register = { ... } };`
struct InstructionEntry {
    /// Bit pattern string (e.g., "0001'00rr")
    pattern: String,
    /// Handler function specification
    handler: HandlerSpec,
    /// Optional where clause with variable bindings
    where_clause: Option<WhereClause>,
}

impl Parse for InstructionEntry {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let pattern_lit: LitStr = input.parse()?;
        let pattern = pattern_lit.value();

        input.parse::<Token![=>]>()?;

        let handler: HandlerSpec = input.parse()?;

        let where_clause = if input.peek(Token![where]) {
            Some(input.parse()?)
        } else {
            None
        };

        Ok(InstructionEntry {
            pattern,
            handler,
            where_clause,
        })
    }
}

/// The complete instruction table definition.
///
/// Contains all metadata and instruction entries that define the decoder.
struct InstructionTable {
    /// The opcode type (u8, u16, u32, or u64) used for pattern matching
    opcode_type: Type,
    /// Optional type that handlers receive (converted from opcode_type)
    handler_opcode_type: Option<Type>,
    /// Name of the generated dispatcher function
    dispatcher_name: Ident,
    /// Type of the context parameter passed to handlers
    context_type: Type,
    /// All instruction pattern entries
    entries: Vec<InstructionEntry>,
}

impl Parse for InstructionTable {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        // type Opcode = u8;
        input.parse::<Token![type]>()?;
        let _: Ident = input.parse()?; // "Opcode"
        input.parse::<Token![=]>()?;
        let opcode_type: Type = input.parse()?;
        input.parse::<Token![;]>()?;

        // Optional: handler_opcode = Instruction;
        let mut handler_opcode_type = None;
        let mut dispatcher_name = None;
        let mut context_type = None;

        // Parse configuration lines in any order
        while input.peek(Ident) && !input.peek(LitStr) {
            let ident: Ident = input.parse()?;
            input.parse::<Token![=]>()?;

            match ident.to_string().as_str() {
                "handler_opcode" => {
                    let handler_type: Type = input.parse()?;
                    handler_opcode_type = Some(handler_type);
                }
                "dispatcher" => {
                    let name: Ident = input.parse()?;
                    dispatcher_name = Some(name);
                }
                "context" => {
                    let ctx_type: Type = input.parse()?;
                    context_type = Some(ctx_type);
                }
                _ => {
                    return Err(syn::Error::new(ident.span(), "Unknown configuration key"));
                }
            }
            input.parse::<Token![;]>()?;
        }

        let dispatcher_name = dispatcher_name
            .ok_or_else(|| syn::Error::new(input.span(), "Missing 'dispatcher' configuration"))?;
        let context_type = context_type
            .ok_or_else(|| syn::Error::new(input.span(), "Missing 'context' configuration"))?;

        // Parse instruction entries
        let mut entries = Vec::new();
        while !input.is_empty() {
            entries.push(input.parse()?);
            input.parse::<Token![;]>()?;
        }

        Ok(InstructionTable {
            opcode_type,
            handler_opcode_type,
            dispatcher_name,
            context_type,
            entries,
        })
    }
}

/// A parsed and analyzed bit pattern.
///
/// After parsing a pattern string like `"0001'00rr"`, this contains:
/// - Which bits are fixed (mask/value)
/// - Which bits are variables (variables map)
/// - Which bits are wildcards (wildcard_bits)
#[derive(Debug, Clone)]
struct ParsedPattern {
    /// Mask where 1 = fixed bit, 0 = variable or wildcard
    mask: u64,
    /// Expected values for fixed bits (where mask = 1)
    value: u64,
    /// Variables extracted from pattern: var_name -> (bit_position, num_bits)
    /// e.g., "rr" from "0001'00rr" -> ("r", (0, 2))
    variables: HashMap<String, (u8, u8)>,
    /// Bitmask of wildcard positions (1 = wildcard bit)
    wildcard_bits: u64,
    /// Total bit width (8, 16, 32, or 64)
    bit_width: usize,
}

/// Parses a pattern string into a structured representation.
///
/// Pattern syntax:
/// - '0', '1': Fixed bits
/// - 'a-z': Variable bits (consecutive same letters form a multi-bit variable)
/// - '_', '.': Wildcard bits (don't care)
/// - '\'': Visual separator (ignored)
///
/// # Examples
/// - `"00011000"` -> fixed pattern (mask=0xFF, value=0x18)
/// - `"0001'00rr"` -> pattern with 2-bit variable 'r' at position 0-1
/// - `"11rr'____"` -> pattern with variable 'r' and 4 wildcard bits
fn parse_pattern(pattern: &str) -> ParsedPattern {
    let pattern = pattern.trim();

    // Remove single quotes (visual separators)
    let pattern_clean: String = pattern.chars().filter(|&c| c != '\'').collect();
    let bit_width = pattern_clean.len();

    assert!(
        bit_width == 8 || bit_width == 16 || bit_width == 32 || bit_width == 64,
        "Pattern must be exactly 8, 16, 32, or 64 bits. Got {} bits: {} (cleaned: {})",
        bit_width,
        pattern,
        pattern_clean
    );

    let mut mask = 0u64;
    let mut value = 0u64;
    let mut wildcard_bits = 0u64;
    let mut var_positions: HashMap<char, Vec<u8>> = HashMap::new();

    for (i, ch) in pattern_clean.chars().enumerate() {
        let bit_pos = (bit_width - 1 - i) as u8; // MSB first

        match ch {
            '0' => {
                mask |= 1 << bit_pos;
                // value bit stays 0
            }
            '1' => {
                mask |= 1 << bit_pos;
                value |= 1 << bit_pos;
            }
            '_' | '.' => {
                // Wildcard - don't care bit (not in mask, not a variable)
                wildcard_bits |= 1 << bit_pos;
            }
            c if c.is_ascii_lowercase() => {
                var_positions.entry(c).or_default().push(bit_pos);
            }
            _ => panic!(
                "Invalid pattern character: '{}'. Use 0/1 for fixed bits, a-z for variables, _ or . for wildcards, ' for visual separation",
                ch
            ),
        }
    }

    // Convert var positions to (start_bit, num_bits)
    let mut variables = HashMap::new();
    for (var_char, positions) in var_positions {
        let min_pos = *positions.iter().min().unwrap();
        let num_bits = positions.len() as u8;
        variables.insert(var_char.to_string(), (min_pos, num_bits));
    }

    ParsedPattern {
        mask,
        value,
        variables,
        wildcard_bits,
        bit_width,
    }
}

/// Generates all possible opcode values by expanding pattern variables.
///
/// For a pattern like `"0001'00rr"` with `r: Register = { 00 => R0, 01 => R1 }`,
/// this generates 2 variants:
/// - `0b00010000` with binding `r -> R0`
/// - `0b00010001` with binding `r -> R1`
///
/// Each variant includes the complete opcode value and the const generic bindings
/// to pass to the handler function.
///
/// # Returns
/// Vec of `(opcode_value, bindings)` where bindings is a list of
/// `(var_name, var_ident, const_value)` tuples.
fn generate_opcode_variants(
    pattern: &ParsedPattern,
    bindings: &[VariableBinding],
) -> Vec<(u64, Vec<(String, Ident, TokenStream2)>)> {
    // Collect all variables with their bit positions and binding types
    let mut var_info: Vec<(&str, u8, u8, BindingValue)> = Vec::new();

    for (var_name, &(bit_pos, num_bits)) in &pattern.variables {
        // Check if this variable has a binding in the where clause
        if let Some(binding) = bindings.iter().find(|b| &b.name == var_name) {
            var_info.push((var_name, bit_pos, num_bits, binding.value.clone()));
        } else {
            // No binding - use raw bit value as u8 (for primitive type generics)
            let var_ident = format_ident!("{}", var_name);
            let raw_value = BindingValue::ConstFn(quote! { #var_ident });
            var_info.push((var_name, bit_pos, num_bits, raw_value));
        }
    }

    // Collect phantom variables (bindings that don't correspond to pattern variables)
    // These are constant expressions that should be added to every variant
    let mut phantom_bindings: Vec<(String, Ident, TokenStream2)> = Vec::new();
    for binding in bindings {
        if !pattern.variables.contains_key(&binding.name) {
            // This is a phantom variable - evaluate it as a constant
            let var_ident = format_ident!("{}", binding.name);
            let value = match &binding.value {
                BindingValue::Mappings(mappings) => {
                    // For phantom variables with manual mappings, just use the first variant
                    // (typically there should only be one for phantom variables)
                    if mappings.len() != 1 {
                        panic!(
                            "Phantom variable '{}' should have exactly one mapping value",
                            binding.name
                        );
                    }
                    let variant = &mappings[0].variant;
                    if let Some(enum_type) = &binding.enum_type {
                        quote! { #enum_type::#variant }
                    } else {
                        quote! { #variant }
                    }
                }
                BindingValue::ConstFn(expr) => {
                    // Const expression - use as-is (no variables to substitute)
                    expr.clone()
                }
            };
            phantom_bindings.push((binding.name.clone(), var_ident, value));
        }
    }

    if var_info.is_empty() {
        // No pattern variables, just return the base pattern with phantom bindings
        return vec![(pattern.value, phantom_bindings)];
    }

    // Recursively generate all combinations of variable values
    let mut results = Vec::new();
    generate_combinations(
        pattern.value,
        &var_info,
        0,
        vec![],
        HashMap::new(),
        &mut results,
    );

    // Add phantom bindings to all results
    if !phantom_bindings.is_empty() {
        for (_opcode, bindings_vec) in &mut results {
            bindings_vec.extend(phantom_bindings.clone());
        }
    }

    results
}

/// Holds raw binding information before substitution
#[derive(Clone)]
enum RawBinding {
    /// Manual enum variant mapping
    Variant(TokenStream2),
    /// Const function expression that needs variable substitution
    ConstFnExpr(TokenStream2),
}

/// Recursively generates all combinations of variable assignments.
///
/// This expands the cartesian product of all possible variable values.
/// For manual mappings, it uses the explicit variant list.
/// For const functions, it generates all possible bit values (0 to 2^num_bits - 1).
fn generate_combinations(
    current_opcode: u64,
    var_info: &[(&str, u8, u8, BindingValue)],
    index: usize,
    current_bindings: Vec<(String, Ident, RawBinding)>,
    current_bit_values: HashMap<String, u64>,
    results: &mut Vec<(u64, Vec<(String, Ident, TokenStream2)>)>,
) {
    if index >= var_info.len() {
        // At the leaf: all variables have been expanded
        // Now substitute all variables in const function expressions
        let final_bindings: Vec<(String, Ident, TokenStream2)> = current_bindings
            .into_iter()
            .map(|(name, ident, raw_binding)| {
                let value = match raw_binding {
                    RawBinding::Variant(v) => v,
                    RawBinding::ConstFnExpr(expr) => {
                        // Substitute all variables in the expression
                        substitute_all_variables(&expr, &current_bit_values)
                    }
                };
                (name, ident, value)
            })
            .collect();

        results.push((current_opcode, final_bindings));
        return;
    }

    let (var_name, bit_pos, num_bits, binding_value) = &var_info[index];

    match binding_value {
        BindingValue::Mappings(mappings) => {
            // Manual mapping: expand all bit patterns
            for mapping in mappings {
                let bits_value =
                    u64::from_str_radix(&mapping.bits, 2).expect("Invalid binary string");
                let new_opcode = current_opcode | (bits_value << bit_pos);

                let mut new_bindings = current_bindings.clone();
                let variant = &mapping.variant;
                new_bindings.push((
                    var_name.to_string(),
                    format_ident!("{}", var_name),
                    RawBinding::Variant(quote! { #variant }),
                ));

                let mut new_bit_values = current_bit_values.clone();
                new_bit_values.insert(var_name.to_string(), bits_value);

                generate_combinations(
                    new_opcode,
                    var_info,
                    index + 1,
                    new_bindings,
                    new_bit_values,
                    results,
                );
            }
        }
        BindingValue::ConstFn(fn_expr) => {
            // Const function: expand all possible bit values
            let max_value = (1u64 << num_bits) - 1;
            for bits_value in 0..=max_value {
                let new_opcode = current_opcode | (bits_value << bit_pos);

                let mut new_bindings = current_bindings.clone();
                let var_ident = format_ident!("{}", var_name);

                // Store the raw expression - we'll substitute later when we have all bit values
                new_bindings.push((
                    var_name.to_string(),
                    var_ident,
                    RawBinding::ConstFnExpr(fn_expr.clone()),
                ));

                let mut new_bit_values = current_bit_values.clone();
                new_bit_values.insert(var_name.to_string(), bits_value);

                generate_combinations(
                    new_opcode,
                    var_info,
                    index + 1,
                    new_bindings,
                    new_bit_values,
                    results,
                );
            }
        }
    }
}

/// Substitutes multiple variables in a token stream.
///
/// Used for const functions that reference multiple variables like `decode_mode(m, x)`.
/// This replaces all variable identifiers with their concrete bit values.
///
/// # Arguments
/// * `tokens` - The token stream to process (e.g., the const function call)
/// * `var_bit_values` - Map of variable names to their bit values
fn substitute_all_variables(
    tokens: &TokenStream2,
    var_bit_values: &HashMap<String, u64>,
) -> TokenStream2 {
    let mut result = TokenStream2::new();

    for tt in tokens.clone().into_iter() {
        match tt {
            proc_macro2::TokenTree::Ident(ref ident) => {
                let ident_str = ident.to_string();
                if let Some(&bit_value) = var_bit_values.get(&ident_str) {
                    // Replace variable with bit value
                    let bit_lit = proc_macro2::Literal::u8_suffixed(bit_value as u8);
                    result.extend(std::iter::once(proc_macro2::TokenTree::Literal(bit_lit)));
                } else {
                    // Keep the identifier as-is
                    result.extend(std::iter::once(tt));
                }
            }
            proc_macro2::TokenTree::Group(group) => {
                // Recursively process grouped tokens
                let inner = substitute_all_variables(&group.stream(), var_bit_values);
                let new_group = proc_macro2::Group::new(group.delimiter(), inner);
                result.extend(std::iter::once(proc_macro2::TokenTree::Group(new_group)));
            }
            _ => {
                result.extend(std::iter::once(tt));
            }
        }
    }

    result
}

fn make_literal(value: u64, bit_width: usize) -> proc_macro2::Literal {
    match bit_width {
        8 => proc_macro2::Literal::u8_suffixed(value as u8),
        16 => proc_macro2::Literal::u16_suffixed(value as u16),
        32 => proc_macro2::Literal::u32_suffixed(value as u32),
        64 => proc_macro2::Literal::u64_suffixed(value),
        _ => panic!("Unsupported bit width: {}", bit_width),
    }
}

fn make_full_mask(bit_width: usize) -> u64 {
    match bit_width {
        8 => 0xFF,
        16 => 0xFFFF,
        32 => 0xFFFF_FFFF,
        64 => 0xFFFF_FFFF_FFFF_FFFF,
        _ => panic!("Unsupported bit width: {}", bit_width),
    }
}

/// Generates a handler function call with const generic arguments.
///
/// Looks up variable values from bindings and wraps them appropriately:
/// - Enum variants: Adds type prefix (e.g., `Register::R0`)
/// - Const fn results: Wraps in braces (e.g., `{ decode_mode(0u8) }`)
/// - Primitive values: Wraps in braces (e.g., `{ 0u8 }`)
fn generate_handler_call(
    handler: &HandlerSpec,
    bindings: &[(String, Ident, TokenStream2)],
    where_clause: &Option<WhereClause>,
    handler_opcode_type: &Option<Type>,
) -> TokenStream2 {
    let handler_name = &handler.name;

    let generic_args: Vec<TokenStream2> = handler
        .generics
        .iter()
        .map(|var_name| {
            // Find the const value for this variable
            let value = bindings
                .iter()
                .find(|(name, _, _)| name == var_name)
                .map(|(_, _, value)| value)
                .unwrap_or_else(|| {
                    panic!("Variable '{}' not found in where clause bindings", var_name)
                });

            // Look up the type annotation from the where clause
            let enum_type = where_clause.as_ref().and_then(|wc| {
                wc.bindings
                    .iter()
                    .find(|b| &b.name == var_name)
                    .and_then(|b| b.enum_type.as_ref())
            });

            // Check if the value is a simple identifier (enum variant)
            let value_str = value.to_string();
            if value_str.chars().all(|c| c.is_alphanumeric() || c == '_') {
                // Simple identifier - could be an enum variant
                if let Some(enum_type) = enum_type {
                    // Add enum type prefix for variants
                    quote! { { #enum_type::#value } }
                } else {
                    // Primitive value or untyped
                    quote! { { #value } }
                }
            } else {
                // Complex expression (const function call) - already complete
                quote! { { #value } }
            }
        })
        .collect();

    // Convert opcode if handler_opcode_type is specified
    let opcode_arg = if let Some(handler_type) = handler_opcode_type {
        quote! { #handler_type(opcode) }
    } else {
        quote! { opcode }
    };

    if generic_args.is_empty() {
        quote! { #handler_name(ctx, #opcode_arg) }
    } else {
        quote! { #handler_name::<#(#generic_args),*>(ctx, #opcode_arg) }
    }
}

/// The main procedural macro for generating instruction decoders.
///
/// This macro takes an instruction table definition and generates an optimized
/// dispatcher function with compile-time branch elimination.
///
/// # Syntax
///
/// ```ignore
/// instruction_table! {
///     type Opcode = u8;           // Opcode type (u8, u16, u32, or u64)
///
///     dispatcher = dispatch;      // Name of generated function
///     context = Cpu;              // Type passed to handlers
///
///     "pattern" => handler<{var}> where {
///         var: Type = mapping_or_const_fn
///     };
///     ...
/// }
/// ```
///
/// # Generated Code
///
/// Generates a function with signature:
/// ```ignore
/// pub fn dispatcher_name(ctx: &mut ContextType, opcode: OpcodeType)
/// ```
///
/// The function contains a match expression that:
/// - Matches exact opcodes for patterns without wildcards
/// - Uses masked matching (`op & mask == value`) for patterns with wildcards
/// - Calls handlers with const generic arguments based on variable bindings
/// - Panics on unhandled opcodes
#[proc_macro]
pub fn instruction_table(input: TokenStream) -> TokenStream {
    let table = parse_macro_input!(input as InstructionTable);

    let opcode_type = &table.opcode_type;
    let dispatcher_name = &table.dispatcher_name;
    let context_type = &table.context_type;

    // Generate match arms for all instruction patterns
    let mut match_arms = Vec::new();
    let mut seen_patterns: Vec<(u64, u64)> = Vec::new(); // Deduplication: (mask, value) pairs

    for entry in &table.entries {
        let pattern = parse_pattern(&entry.pattern);
        let bit_width = pattern.bit_width;
        let bindings = entry
            .where_clause
            .as_ref()
            .map(|wc| wc.bindings.as_slice())
            .unwrap_or(&[]);

        // Determine if we need to expand variables into multiple match arms
        // Variables with where clause bindings get expanded (e.g., r: Register = { ... })
        // Variables without bindings are passed as raw u8 values
        let has_expandable_vars = bindings
            .iter()
            .any(|b| pattern.variables.contains_key(&b.name));

        let has_any_vars = !pattern.variables.is_empty();

        if has_expandable_vars || has_any_vars {
            // Expand pattern into all variable combinations
            // E.g., "00rr" with r=2bits generates 4 opcodes: 0x00, 0x01, 0x02, 0x03
            let variants = generate_opcode_variants(&pattern, bindings);

            // Calculate the full mask including expanded variable bits
            // This is used for wildcard patterns to create guard expressions
            let mut expanded_mask = pattern.mask;
            for binding in bindings {
                if let Some(&(bit_pos, num_bits)) = pattern.variables.get(&binding.name) {
                    // Mark variable bits as fixed in the mask since we expanded them
                    for i in 0..num_bits {
                        expanded_mask |= 1 << (bit_pos + i);
                    }
                }
            }

            for (opcode, var_bindings) in variants {
                if pattern.wildcard_bits != 0 {
                    // Pattern has wildcards - use guard-based match
                    // E.g., "11rr'____" with r=R0 matches 0b1100_0000..0b1100_1111
                    let handler_call = generate_handler_call(
                        &entry.handler,
                        &var_bindings,
                        &entry.where_clause,
                        &table.handler_opcode_type,
                    );

                    // Skip if already covered by an exact match
                    let full_mask = make_full_mask(bit_width);
                    let dominated = seen_patterns
                        .iter()
                        .any(|(m, v)| *m == full_mask && *v == opcode);

                    if !dominated {
                        let mask_lit = make_literal(expanded_mask, bit_width);
                        let value_lit = make_literal(opcode, bit_width);
                        match_arms.push(quote! {
                            op if op & #mask_lit == #value_lit => { #handler_call }
                        });
                        seen_patterns.push((expanded_mask, opcode));
                    }
                } else {
                    // No wildcards - exact opcode match
                    let full_mask = make_full_mask(bit_width);
                    let key = (full_mask, opcode);
                    if !seen_patterns.contains(&key) {
                        let handler_call = generate_handler_call(
                            &entry.handler,
                            &var_bindings,
                            &entry.where_clause,
                            &table.handler_opcode_type,
                        );
                        let opcode_lit = make_literal(opcode, bit_width);
                        match_arms.push(quote! {
                            #opcode_lit => { #handler_call }
                        });
                        seen_patterns.push(key);
                    }
                }
            }
        } else if pattern.wildcard_bits != 0 || !pattern.variables.is_empty() {
            // Wildcard pattern with no variable bindings - single masked match
            let mask = pattern.mask;
            let value = pattern.value;
            let handler_call = generate_handler_call(
                &entry.handler,
                &[],
                &entry.where_clause,
                &table.handler_opcode_type,
            );

            let mask_lit = make_literal(mask, bit_width);
            let value_lit = make_literal(value, bit_width);
            match_arms.push(quote! {
                op if op & #mask_lit == #value_lit => { #handler_call }
            });
            seen_patterns.push((mask, value));
        } else {
            // Fixed pattern - simple exact match
            let opcode = pattern.value;
            let full_mask = make_full_mask(bit_width);
            let key = (full_mask, opcode);
            if !seen_patterns.contains(&key) {
                let handler_call = generate_handler_call(
                    &entry.handler,
                    &[],
                    &entry.where_clause,
                    &table.handler_opcode_type,
                );
                let opcode_lit = make_literal(opcode, bit_width);
                match_arms.push(quote! {
                    #opcode_lit => { #handler_call }
                });
                seen_patterns.push(key);
            }
        }
    }

    // Generate the dispatcher function
    let expanded = quote! {
        #[inline]
        pub fn #dispatcher_name(ctx: &mut #context_type, opcode: impl Into<#opcode_type>) {
            let opcode = opcode.into();
            match opcode {
                #(#match_arms)*
                _ => panic!("Unhandled opcode: 0x{:02X}", opcode),
            }
        }
    };

    TokenStream::from(expanded)
}
